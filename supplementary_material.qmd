---
title: "A latent trajectory analysis in glycemic control and diabetic retinopathy screening coverage 2011-2023: A municipality-level study"
subtitle: Supplementary Material
editor: visual
tbl-cap-location: top
#number-sections: true
format:
  html:
    toc: true
    toc_float: true
    toc_depth: 2
    number_sections: true
    code_folding: hide
    theme: readable
  pdf:
    number-sections: true
    colorlinks: true
    keeptex: true
    include-in-header: 
      text: |
        \usepackage{booktabs}
        \usepackage{siunitx}
        \newcolumntype{d}{S[
            input-open-uncertainty=,
            input-close-uncertainty=,
            parse-numbers = false,
            table-align-text-pre=false,
            table-align-text-post=false
         ]}
  docx: default
prefer-html: true
date: 'last-modified'
execute:
  echo: false
  warning: true
  error: true
  cache: false
---

```{r}
#| echo: false
#| warning: false

# ðŸ“š Load required libraries
library(readr)
library(dplyr)
library(tidyr)
library(ggplot2)
library(stringr)
library(purrr)
library(patchwork)
library(tidyverse)
library(knitr)
library(kableExtra)
library(ggtext)
library(Cairo)
library(extrafont)
library(hrbrthemes)
library(directlabels)
library(ggrepel)
library(readxl)
library(scales)
library(ggsci)
library(lcmm)
library(MixAll)
library(kml)
library(traj)
library(lmerTest)
library(plyr)
library(psych)
library(fpc)
library(mclust)
library(rcompanion)
library(gridExtra)
library(tidyLPA)
library(MASS)
library(broom)
library(skimr)
library(gtExtras)
library(pander)
library(BayesFactor)
library(modelsummary)
library(gt)
library(gtsummary)
library(survival)
library(xtable)
library(htmltools)
library(tibble)
library(LCTMtools)
library(grid)
library(rlang)
library(lmtest)
library(quarto)
library(Hmisc)



options(scipen=10000000)
```

**Rolando Silva-Jorquera^1^, Kasim Allel^2^, Hassan Haghparast-Bidgoli^1^, Paul Nderitu^3^, Claudio Zett^4^, Abraham Olvera-Barrios^5,6^, Alasdair Warwick^5,6,7^**

^1^Institute for Global Health, University College London, UK.

^2^Nuffield Department of Population Health, University of Oxford, UK

^3^Faculty of Life Sciences and Medicine, Kingâ€™s College London, UK

^4^Pontificia Universidad CatÃ³lica de ValparaÃ­so, Chile

^5^NIHR Biomedical Research Centre at Moorfields Eye Hospital NHS Foundation Trust

^6^Institute of Ophthalmology, University College London, UK

^7^Institute of Cardiovascular Science, University College London, UK

------------------------------------------------------------------------

```{r}
#| message: false
#| warning: false
#| tbl-align: left


structure_table <- data.frame(
  Model = LETTERS[1:10],
  Description = c(
    "Linear without random effects with equal variances",
    "Linear without random effects with varying variances",
    "Quadratic without random effects",
    "Cubic without random effects",
    "Linear with random intercept",
    "Linear with random intercept and slope",
    "Quadratic with random intercept and slope",
    "Quadratic with random intercept and slope and proportional variance",
    "Cubic with random intercept and slope",
    "Cubic with random intercept and slope and proportional variance"
  ),
  Interpretation = c(
    "Captures linear trends assuming constant variance across latent classes and no individual-level variability.",
    "Captures linear trends allowing class-specific variances, without accounting for individual-level random effects.",
    "Captures curvilinear (quadratic) trajectories with fixed effects only and shared variance structure.",
    "Captures complex nonlinear (cubic) fixed trends without random effects or variance heterogeneity.",
    "Allows individuals to vary in their baseline levels (intercepts) while modeling linear overall trends.",
    "Accounts for both baseline and slope variability across individuals in modeling linear trends.",
    "Models quadratic trajectories with random effects on both intercept and slope, allowing individual variation.",
    "Same as previous, but allows proportional variance differences across latent classes for more flexibility.",
    "Captures complex cubic trends while accounting for individual variation in intercepts and slopes.",
    "Extends the cubic random effects model by allowing class-specific proportional variance structures."
  ),
  stringsAsFactors = FALSE
)

# View table
structure_table %>% 
  gt::gt() %>%
  tab_header(
    title = md("**Supplementary Table S1. Description of the 10 candidate model structures tested in the LCMM analysis**")) %>% 
  tab_options(
    table.font.size = 10,
    data_row.padding = px(1),
    table.border.top.color = "black",
    heading.border.bottom.color = "black",
    row_group.border.top.color = "black",
    row_group.border.bottom.color = "white",
    table.border.bottom.color = "white",
    column_labels.border.top.color = "black",
    column_labels.border.bottom.color = "black",
    table_body.border.bottom.color = "black",
    table_body.hlines.color = "white") %>% 
  tab_source_note(source_note = md(" **Note:** Each model structure was applied across multiple class solutions (1â€“7 classes) and evaluated using BIC, classification adequacy, and visual interpretability to identify optimal specifications for each outcome and period."))


```

```{r}
#| message: false
#| warning: false
#| tbl-align: left


table_s2 <- tibble::tibble(
  Tool = c(
    "Model Structure",
    "BIC, AIC, LRT",
    "APPA",
    "Odds of Correct Classification (OCC)",
    "Mismatch",
    "Entropy",
    "Relative Entropy",
    "Degrees of Separation",
    "Envelope of Residuals"
  ),
  `Criteria for a good model` = c(
    "â€”",
    "Lowest BIC/AIC",
    "> 0.70 for each class",
    "> 5.0 for each class",
    "Close to 0",
    "Close to 0",
    "Close to 1 (> 6.0 recommended)",
    "Higher = more separation",
    "Parallel and narrow boundaries"
  ),
  Description = c(
    "COVERAGE_itk = Î²â‚€áµ + Î²â‚áµÂ·YEAR_it + Î²â‚‚áµÂ·YEAR_itÂ² + bâ‚€áµ + bâ‚áµÂ·YEAR_it + bâ‚‚áµÂ·YEAR_itÂ² + Îµâ‚œ (Eq. 1)\nâ†’ Î²: fixed effects; b: random effects; Îµâ‚œ: error term.\nPr(i in class k) = exp(Ï€_k) / Î£ exp(Ï€_l) (Eq. 2)\nâ†’ Ï€_k: class-specific membership parameter.",
    "Likelihood-based tools to evaluate model parsimony and fit.",
    "Average Posterior Probability Assignment;\nmeasures certainty of class membership.",
    "OCC = OCC = (Ï€g * (1 - pg)) / (pg * (1 - Ï€g)) â€” compares expected vs. actual class membership.",
    "Mismatch = Mismatch = Ï€g - ng/N â€” difference between predicted and assigned class size.",
    "Entropy = Entropy = â€“ Î£i Î£g (pig * log(pig)) â€” global uncertainty across posterior probabilities.",
    "Relative Entropy = 1 â€“ (E / (G * log G)) â€” standardized measure of classification uncertainty.",
    "Weighted Mahalanobis distance between predicted class means;\nhigher = more distinct classes.",
    "Residual bounds: mean Â± SD of residuals;\nnon-parallel/wide bounds suggest heteroscedasticity or poor class separation."
  )
)

gt(table_s2) %>%
  tab_header(
    title = md("**Supplementary Table S2. Model structure and commonly assessment tools used in the LCMM analysis**")
  ) %>%
  tab_source_note(
    md("*DoS and residual envelopes were implemented following Peugh & Fan and Elsensohn et al.*")
  ) %>%
  tab_options(
    table.font.size = 11,
    data_row.padding = px(2),
    table.border.top.color = "black",
    heading.border.bottom.color = "black",
    column_labels.border.bottom.color = "black"
  ) 



```

```{r}
#| label: Fig-S1
#| fig-align: left
#| fig-height: 11
#| fig-width: 10
#| warning: false



# Paquetes necesarios
library(dplyr)
library(ggplot2)
library(purrr)
library(tidyr)
library(stringr)
library(scales)
library(patchwork)

# 1. Cargar datos
coverage_2011_2023_noq1 <- read.csv("coverage_2011_2023_noq1.csv") %>%
  arrange(comuna2, ano) %>%
  group_by(comuna2) %>%
  mutate(year = row_number()) %>%   # Ã­ndice seguro
  ungroup() %>%
  mutate(
    id = comuna2,
    drsc = drs_coverage,
    dgcc = dm_coverage
  )

# 2. Cargar modelos
all_models_by_period <- readRDS("all_models_by_period.rds")
#

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ðŸ§  Asignar el coverage_data adecuado a cada modelo por periodo
#for (period_name in names(all_models_by_period)) {
 # period_data <- coverage_data %>% filter(year %in% periods[[period_name]])
  
  #for (model_name in names(all_models_by_period[[period_name]])) {
   # model <- all_models_by_period[[period_name]][[model_name]]
    
   # if (!is.null(model)) {
    #  model$call$data <- period_data
    #  all_models_by_period[[period_name]][[model_name]] <- model
    #}
  #}
#}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ðŸ” Renombrar todos los modelos agregando sufijo de periodo
create_named_models_by_period <- function(all_models_by_period, period_suffixes = names(all_models_by_period)) {
  names(all_models_by_period) <- period_suffixes
  named_models <- list()
  
  for (i in seq_along(all_models_by_period)) {
    models <- all_models_by_period[[i]]
    suffix <- period_suffixes[i]
    renamed_models <- setNames(models, paste0(names(models), "_", suffix))
    named_models[[i]] <- renamed_models
  }
  
  all_named_models <- do.call(c, named_models)
  return(all_named_models)
}

all_named_models <- create_named_models_by_period(all_models_by_period)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ðŸ’¾ Guardar las versiones parchadas
saveRDS(all_models_by_period, "all_models_by_period_with_data.rds")
saveRDS(all_named_models, "all_named_models_with_data.rds")

all_named_models <- readRDS("all_named_models_with_data.rds")

# 4. FunciÃ³n para extraer data de residuos por clase
extract_residual_data <- function(model, nameofoutcome, nameofage = "ano", data, model_label) {
  k <- ifelse(is.null(model$ng), 1, model$ng)
  preds <- model$pred
  names(preds)[6] <- "outcome_value_pred"
  nameofid <- names(model$pred)[1]
  
  model_data <- data %>%
  group_by(.data[[nameofid]]) %>%
  mutate(row_id = row_number()) %>%
  ungroup()

  
  preds <- preds %>%
    group_by(.data[[nameofid]]) %>%
    mutate(row_id = row_number()) %>%
    ungroup()
  
  test <- left_join(preds, model$pprob, by = nameofid) %>%
    left_join(select(model_data, all_of(nameofid), !!nameofoutcome, !!nameofage, row_id),
              by = c(nameofid, "row_id"))
  
  residual_df <- purrr::map_dfr(1:k, function(i) {
    class_col <- if (k == 1) "pred_ss1" else paste0("pred_ss", i)
    test %>%
      filter(k == 1 | class == i) %>%
      mutate(
        Residuals = !!parse_expr(nameofoutcome) - !!parse_expr(class_col),
        ano_real = .data[[nameofage]],
        class_label = paste("Class", i),
        model_label = model_label
      ) %>%
      select(ano_real, Residuals, class_label, model_label)
  })
  
  return(residual_df)
}

# 5. Definir modelos y outcomes a graficar
models_to_plot <- list(
  "DGCC 2011â€“2023" = all_named_models[["5class_linear_nre_homocedastic_dgcc_model_2011_2023"]],
  "DGCC 2011â€“2019" = all_named_models[["4class_linear_nre_homocedastic_dgcc_model_2011_2019"]],
  "DRSC 2011â€“2023" = all_named_models[["4class_linear_nre_homocedastic_drsc_model_2011_2023"]],
  "DRSC 2011â€“2019" = all_named_models[["4class_linear_nre_homocedastic_drsc_model_2011_2019"]]
)
outcomes <- c("dgcc", "dgcc", "drsc", "drsc")
names(outcomes) <- names(models_to_plot)

# 6. Extraer todos los datos de residuos
residual_data_all <- purrr::pmap_dfr(
  list(models_to_plot, outcomes, names(models_to_plot)),
  ~ extract_residual_data(..1, ..2, nameofage = "ano", data = coverage_2011_2023_noq1, model_label = ..3)
)

# 7. Preparar niveles de factores
residual_data_all$class_label <- factor(residual_data_all$class_label, levels = paste("Class", 1:4))
residual_data_all$model_label <- factor(residual_data_all$model_label, 
                                        levels = c("DGCC 2011â€“2023", "DGCC 2011â€“2019", "DRSC 2011â€“2023", "DRSC 2011â€“2019"))

# 8. FunciÃ³n para plotear cada modelo
plot_residual_block <- function(df, title) {
  ggplot(df, aes(x = ano_real, y = Residuals)) +
    geom_point(size = 0.2, alpha = 0.3) +
    stat_summary(fun = mean, geom = "line", color = "darkcyan", size = 0.6) +
    facet_wrap(~ class_label, ncol = 5) +
    ylim(-1, 1) +
    scale_x_continuous(breaks = seq(2011, 2023, 2)) +
    theme_bw(base_size = 9) +
    labs(x = "Year", y = "Residuals", title = title) +
    theme(
      strip.text = element_text(face = "bold", size = 8),
      axis.text.x = element_text(size = 7, angle = 45, hjust = 1),
      axis.text.y = element_text(size = 7),
      plot.title = element_text(face = "bold", size = 10, hjust = 0),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank()
    )
}

# 9. Crear los bloques de plots
plot_dgcc_2023 <- plot_residual_block(residual_data_all %>% filter(model_label == "DGCC 2011â€“2023"), "DGCC 2011â€“2023 â€“ Structure A")
plot_dgcc_2019 <- plot_residual_block(residual_data_all %>% filter(model_label == "DGCC 2011â€“2019"), "DGCC 2011â€“2019 â€“ Structure A")
plot_drsc_2023 <- plot_residual_block(residual_data_all %>% filter(model_label == "DRSC 2011â€“2023"), "DRSC 2011â€“2023 â€“ Structure A")
plot_drsc_2019 <- plot_residual_block(residual_data_all %>% filter(model_label == "DRSC 2011â€“2019"), "DRSC 2011â€“2019 â€“ Structure A")

# 10. Combinar todos los grÃ¡ficos con patchwork
final_residual_plot <- (
  plot_dgcc_2023 /
    plot_dgcc_2019 /
    plot_drsc_2023 /
    plot_drsc_2019
) +  
  plot_annotation(
    title = "Supplementary Figure S1. Standardised residual plots by latent class under Model A",
    subtitle = "Each panel shows the distribution of standardised residuals over time (Year) for a given latent class under a linear fixed-effects, homoscedastic model (Model A). The first row corresponds to DGCC (2011â€“2023), the second to DGCC (2011â€“2019), the third to DRSC (2011â€“2023), and the fourth to DRSC (2011â€“2019).",
    theme = theme(
      plot.title = element_text(size = 16, face = "bold"),
      plot.subtitle = element_text(size = 10)
    )
 
)
# 11. Mostrar
final_residual_plot



```

**Supplementary Figures S2â€“S5. *Latent class selection elbows plots across ten different structures in DGCC 2011-2023.***\
Each figure presents model comparison panels used to guide latent class number selection for a given outcome and time period. Within each panel, the black line displays the Bayesian Information Criterion (BIC) across models with 1 to 7 latent classes, allowing visual identification of the â€œelbow pointâ€ where model fit improvements begin to plateau. The vertical stacked bars represent the proportion of the population assigned to each class at each solution, with darker red hues indicating smaller class sizes. Together, the BIC curve and class distribution inform model selection by balancing statistical fit and classification adequacy. These plots support the decisions reported in Table 1 and discussed in the model adequacy assessment.

```{r}
#| message: false
#| warning: false
#| fig-height: 14
#| fig-width: 10
#| fig-cap: "Figure S2. Latent class selection plots for DGCC (2011â€“2023)"

# â”€â”€â”€â”€â”€ Load libraries â”€â”€â”€â”€â”€
library(dplyr)
library(ggplot2)
library(tidyr)
library(stringr)
library(purrr)
library(gridExtra)
library(readr)



# â”€â”€â”€â”€â”€ 1B. Automatically exclude models with abnormally high BICs â”€â”€â”€â”€â”€
model_adequacy_table <- readr::read_csv("model_adequacy_table.csv")



models_to_exclude <- model_adequacy_table %>%
  group_by(Model) %>%
  arrange(-BIC) %>% 
  filter(BIC > 1e6) %>% 
  pull(Model)
            


model_adequacy_table <- model_adequacy_table %>%
  filter(!Model %in% models_to_exclude)



filtered_df <- model_adequacy_table %>%
  filter(!str_detect(Model, "2020_2023")) %>%
  mutate(
    Structure = Model %>%
      str_replace("^[0-9]+class_", "") %>%
      str_replace("_model_.*", ""),
    Period = str_extract(Model, "\\d{4}_\\d{4}"),
    Outcome = str_extract(Model, "_(drsc|dgcc)_") %>% str_replace_all("_", "")
  )

# â”€â”€â”€â”€â”€ 2. Create Pretty Title Mapping (Model A | DGCC | 2011â€“2023) â”€â”€â”€â”€â”€
structure_labels <- filtered_df %>%
  mutate(
    Outcome = toupper(Outcome),
    Label = case_when(
      str_detect(Structure, "linear_nre_homocedastic") ~ "A",
      str_detect(Structure, "linear_nre_heterocedastic") ~ "B",
      str_detect(Structure, "quadratic_nre") ~ "C",
      str_detect(Structure, "cubic_nre") ~ "D",
      str_detect(Structure, "linear_random_intercept_slope") ~ "F",
      str_detect(Structure, "linear_random_intercept") ~ "E",
      str_detect(Structure, "quadratic_random_effects_prop") ~ "H",
      str_detect(Structure, "quadratic_random_effects") ~ "G",
      str_detect(Structure, "cubic_random_effects_prop") ~ "J",
      str_detect(Structure, "cubic_random_effects") ~ "I",
      TRUE ~ "Other"
    ),
    Period_pretty = str_replace(Period, "_", "â€“"),
    PrettyTitle = paste("Model", Label, "|", Outcome, "|", Period_pretty)
  ) %>%
  distinct(Structure, Period, PrettyTitle)

# â”€â”€â”€â”€â”€ 3. Prepare long-format class proportions â”€â”€â”€â”€â”€
proportion_cols <- names(filtered_df)[str_detect(names(filtered_df), "^%class")]

class_df_long <- filtered_df %>%
  pivot_longer(cols = all_of(proportion_cols),
               names_to = "Class",
               values_to = "Proportion") %>%
  mutate(Class = factor(Class, levels = proportion_cols))

# â”€â”€â”€â”€â”€ 4. Filter combinations with at least 2 G values â”€â”€â”€â”€â”€
valid_keys <- class_df_long %>%
  distinct(Structure, Period, G) %>%
  group_by(Structure, Period) %>%
  dplyr::summarise(n_G = n(), .groups = "drop") %>%
  filter(n_G >= 2) %>%
  select(Structure, Period)

# Add pretty titles to the valid ones
plot_keys <- valid_keys %>%
  left_join(structure_labels, by = c("Structure", "Period"))

# â”€â”€â”€â”€â”€ 5. Define plotting function with custom title â”€â”€â”€â”€â”€
plot_elbow_stack <- function(df_model, title = NULL) {
  structure <- unique(df_model$Structure)
  period <- unique(df_model$Period)
  
  df_summary <- df_model %>%
    group_by(G, Class) %>%
    dplyr::summarise(Proportion = mean(Proportion, na.rm = TRUE), .groups = "drop")
  
  bic_df <- df_model %>%
    group_by(G) %>%
    dplyr::summarise(BIC = mean(BIC, na.rm = TRUE), .groups = "drop")
  
  if (nrow(bic_df) < 2) {
    message("Skipping plot for ", structure, " | ", period, ": not enough BIC values")
    return(NULL)
  }
  
  bic_range <- range(bic_df$BIC, na.rm = TRUE)
  bic_min <- bic_range[1]
  bic_max <- bic_range[2]
  scale_factor <- 100 / (bic_max - bic_min)
  
  bic_df <- bic_df %>%
    mutate(BIC_scaled = (BIC - bic_min) * scale_factor)
  
  ggplot(df_summary, aes(x = factor(G), y = Proportion, fill = Class)) +
    geom_bar(stat = "identity", color = "white") +
    scale_fill_brewer(palette = "Reds") +
    geom_line(data = bic_df, aes(x = factor(G), y = BIC_scaled, group = 1),
              inherit.aes = FALSE, color = "black", size = 1) +
    geom_point(data = bic_df, aes(x = factor(G), y = BIC_scaled),
               inherit.aes = FALSE, color = "black", size = 2) +
    scale_y_continuous(
      name = "% Proportion of Population",
      sec.axis = sec_axis(~ . / scale_factor + bic_min, name = "BIC")
    ) +
    labs(
      title = title,
      x = "Number of Classes",
      fill = "Class"
    ) +
    theme_minimal() +
    theme(legend.position = "none")
}

# â”€â”€â”€â”€â”€ 6. Generate plots with titles â”€â”€â”€â”€â”€
plot_data_list <- purrr::map2(
  .x = plot_keys$Structure,
  .y = plot_keys$Period,
  .f = ~ class_df_long %>% filter(Structure == .x, Period == .y)
)

plots <- purrr::map2(
  .x = plot_data_list,
  .y = plot_keys$PrettyTitle,
  .f = plot_elbow_stack
)

# Remove NULL plots
valid_idx <- purrr::map_lgl(plots, ~ !is.null(.))
plots <- plots[valid_idx]
names(plots) <- plot_keys$PrettyTitle[valid_idx]

# â”€â”€â”€â”€â”€ 7. Helper: Reorder plots by Model Aâ€“J â”€â”€â”€â”€â”€
extract_label <- function(name) {
  str_extract(name, "Model [A-J]") %>% str_remove("Model ")
}

order_plot_group_by_label <- function(plot_list) {
  df_order <- tibble(name = names(plot_list)) %>%
    mutate(label = extract_label(name)) %>%
    mutate(order = match(label, LETTERS[1:10])) %>%
    arrange(order)
  plot_list[df_order$name]
}

# â”€â”€â”€â”€â”€ 8. Helper function to plot any group (by outcome & period) â”€â”€â”€â”€â”€
plot_group_grid <- function(plots, outcome, period) {
  # Normalize inputs to match title format
  outcome <- toupper(outcome)
  period_pretty <- str_replace(period, "_", "â€“")
  
  group <- plots[str_detect(names(plots), outcome) &
                   str_detect(names(plots), period_pretty)]
  
  if (length(group) == 0) {
    message("âŒ No plots found for ", outcome, " | ", period_pretty)
  } else {
    ordered_group <- order_plot_group_by_label(group)
    
    grid.arrange(
      grobs = ordered_group,
      ncol = 2,
      nrow = 5,
      top = paste0(outcome, " ", period_pretty, " â€” Models A to J")
    )
  }
}

# â”€â”€â”€â”€â”€ 9. Call the function for all desired groups â”€â”€â”€â”€â”€
plot_group_grid(plots, outcome = "dgcc", period = "2011_2023")





```

```{r}
#| message: false
#| warning: false
#| fig-height: 14
#| fig-width: 10
#| fig-cap: "Figure S3. Latent class selection plots for DGCC (2011â€“2019)"

# Reordenar y plotear
plot_group_grid(plots, outcome = "dgcc", period = "2011_2019")



```

```{r}
#| message: false
#| warning: false
#| fig-height: 14
#| fig-width: 10
#| fig-cap: "Figure S4. Latent class selection plots for DRSC (2011â€“2023)"
#| 
plot_group_grid(plots, outcome = "drsc", period = "2011_2023")


```

```{r}
#| message: false
#| warning: false
#| fig-height: 14
#| fig-width: 10
#| fig-cap: "Figure S4. Latent class selection plots for DRSC (2011â€“2023)"

# Reordenar y plotear
plot_group_grid(plots, outcome = "drsc", period = "2011_2019")

```

```{r}
#| echo: false
#| message: false
#| warning: false
#| paged-print: false

selected_structures <- c(
  "class_cubic_nre_dgcc_model_2011_2023",
  "class_quadratic_nre_dgcc_model_2011_2019",
  "class_cubic_nre_drsc_model_2011_2023",
  "class_quadratic_random_effects_prop_drsc_model_2011_2019"
)

model_adequacy_table %>%
  filter(str_detect(Model, paste(selected_structures, collapse = "|"))) %>% 
  filter(str_detect(Model, "2011_2023") | str_detect(Model, "2011_2019")) %>%
  mutate(
    Period = case_when(
      str_detect(Model, "2011_2023") ~ "2011â€“2023",
      str_detect(Model, "2011_2019") ~ "2011â€“2019",
      TRUE ~ NA_character_
    ),
    Structure = case_when(
      str_detect(Model, "linear_nre_homocedastic") ~ "A",
      str_detect(Model, "linear_nre_heterocedastic") ~ "B",
      str_detect(Model, "quadratic_nre") ~ "C",
      str_detect(Model, "cubic_nre") ~ "D",
      str_detect(Model, "linear_random_intercept_slope") ~ "E",
      str_detect(Model, "linear_random_intercept") ~ "F",
      str_detect(Model, "quadratic_random_effects_prop") ~ "G",
      str_detect(Model, "quadratic_random_effects") ~ "H",
      str_detect(Model, "cubic_random_effects_prop") ~ "I",
      str_detect(Model, "cubic_random_effects") ~ "J",
      TRUE ~ "Unknown"
    ),
    Outcome = case_when(
      str_detect(Model, "dgcc") ~ "DGCC",
      str_detect(Model, "drsc") ~ "DRSC",
      TRUE ~ "Other"
    ),
    non_converged = abs(BIC) > 1e6,  # flag large BIC
    BIC_display = ifelse(non_converged, "*", scales::number(BIC, accuracy = 0.1, big.mark = ","))
  ) %>%
  mutate(
    entropy = round(entropy, 2),
    Lowest_APPA = round(Lowest_APPA * 100, 2),
    Lowest_OCC = round(Lowest_OCC, 1),
    Smallest_Class_Size_Percentage = round(Smallest_Class_Size_Percentage, 1),
    DoS_Mahalanobis = round(DoS_Mahalanobis, 1)
  ) %>%
  select(Outcome, Period, Model, Structure, G, BIC_display, entropy,
         Smallest_Class_Size_Percentage, Lowest_APPA,
         Lowest_OCC, Highest_Mismatch, DoS_Mahalanobis) %>%
  dplyr::rename(
    "NÂº of classes" = G,
    "BIC" = BIC_display,
    "Relative entropy" = entropy,
    "Smallest class size (%)" = Smallest_Class_Size_Percentage,
    "Lowest APPA (%)" = Lowest_APPA,
    "Lowest OCC" = Lowest_OCC,
    "Highest MMV" = Highest_Mismatch,
    "Mahalanobis distance" = DoS_Mahalanobis
  ) %>%
  arrange(Outcome, desc(Period), Structure) %>% 
  select(-Outcome, -Period, -Model) %>%
  #filter(Structure %in% c("D", "C", "G")) %>% 
  gt() %>%
  tab_options(
    table.font.size = 10,
    data_row.padding = px(0),
    table.border.top.color = "black",
    heading.border.bottom.color = "black",
    row_group.border.top.color = "black",
    row_group.border.bottom.color = "white",
    table.border.bottom.color = "white",
    column_labels.border.top.color = "black",
    column_labels.border.bottom.color = "black",
    table_body.border.bottom.color = "black",
    table_body.hlines.color = "white"
  ) %>% 
  tab_style(
   style = cell_text(weight = "bold"),
   locations = cells_body(rows = c(5, 11, 18, 25))
  ) %>% 
  tab_row_group(
    group = "Diabetic retinopathy screening coverage 2011-2019",
    rows = 22:28
  ) %>% 
  tab_row_group(
    group = "Diabetic retinopathy screening coverage 2011-2023",
    rows =15:21
  ) %>% 
  tab_row_group(
    group = "Diabetic glycemic control coverage 2011-2019",
    rows = 8:14
  ) %>% 
  tab_row_group(
    group = "Diabetic glycemic control coverage 2011-2023",
    rows =1:7
  ) %>% 
  tab_source_note(source_note = md("**Abbreviations:** LCMM - Latent class mixture model; BIC - Bayesian information criterion; SCS - Smallest class size; APPA - Average posterior probability; MMV - Mismatch value; OCC - Odds of correct classification. * Model did not converge; BIC not reliable.")) %>% 
  tab_header(
    title = md("**Supplementary Table S3. Number of classes (K=1â€“7) using quadratic and cubic non random effects and quadratic radnom effects proportional structure Model F (proportional covariance structure) by gender**"))

```

```{r}
#| echo: false
#| message: false
#| warning: false
#| paged-print: false


model_adequacy_table <- read.csv("model_adequacy_table.csv")

selected_models <- c(
  "5class_cubic_nre_dgcc_model_2011_2023",
  "4class_quadratic_nre_dgcc_model_2011_2019",
  "4class_cubic_nre_drsc_model_2011_2023",
  "4class_quadratic_random_effects_prop_drsc_model_2011_2019"
)


 model_adequacy_table %>%
  filter(
    (str_detect(Model, "^5class_") & str_detect(Model, "dgcc_model_2011_2023")) |  # <- switch here
    (str_detect(Model, "^4class_") & str_detect(Model, "dgcc_model_2011_2019")) |
    (str_detect(Model, "^4class_") & str_detect(Model, "drsc_model_2011_2023")) |
    (str_detect(Model, "^4class_") & str_detect(Model, "drsc_model_2011_2019"))
  ) %>%
  mutate(
    Period = case_when(
      str_detect(Model, "2011_2023") ~ "2011â€“2023",
      str_detect(Model, "2011_2019") ~ "2011â€“2019",
      TRUE ~ NA_character_
    ),
    Structure = case_when(
      str_detect(Model, "linear_nre_homocedastic") ~ "A",
      str_detect(Model, "linear_nre_heterocedastic") ~ "B",
      str_detect(Model, "quadratic_nre") ~ "C",
      str_detect(Model, "cubic_nre") ~ "D",
      str_detect(Model, "linear_random_intercept_slope") ~ "E",
      str_detect(Model, "linear_random_intercept") ~ "F",
      str_detect(Model, "quadratic_random_effects_prop") ~ "G",
      str_detect(Model, "quadratic_random_effects") ~ "H",
      str_detect(Model, "cubic_random_effects_prop") ~ "I",
      str_detect(Model, "cubic_random_effects") ~ "J",
      TRUE ~ "Unknown"
    ),
    Outcome = case_when(
      str_detect(Model, "dgcc") ~ "DGCC",
      str_detect(Model, "drsc") ~ "DRSC",
      TRUE ~ "Other"
    ),
    non_converged = abs(BIC) > 1e6,  # flag large BIC
    BIC_display = ifelse(non_converged, "*", scales::number(BIC, accuracy = 0.1, big.mark = ","))
  ) %>%
  mutate(
    entropy = round(entropy, 2),
    Lowest_APPA = round(Lowest_APPA * 100, 2),
    Lowest_OCC = round(Lowest_OCC, 1),
    Smallest_Class_Size_Percentage = round(Smallest_Class_Size_Percentage, 1),
    DoS_Mahalanobis = round(DoS_Mahalanobis, 1)
  ) %>%
  select(Outcome, Period, Model, Structure, G, BIC_display, entropy,
         Smallest_Class_Size_Percentage, Lowest_APPA,
         Lowest_OCC, Highest_Mismatch, DoS_Mahalanobis) %>%
  dplyr::rename(
    "NÂº of classes" = G,
    "BIC" = BIC_display,
    "Relative entropy" = entropy,
    "Smallest class size (%)" = Smallest_Class_Size_Percentage,
    "Lowest APPA (%)" = Lowest_APPA,
    "Lowest OCC" = Lowest_OCC,
    "Highest MMV" = Highest_Mismatch,
    "Mahalanobis distance" = DoS_Mahalanobis
  ) %>%
  arrange(Outcome, desc(Period), Structure) %>%
  select(-Outcome, -Period, -Model) %>%
  gt() %>%
  tab_options(
    table.font.size = 10,
    data_row.padding = px(0),
    table.border.top.color = "black",
    heading.border.bottom.color = "black",
    row_group.border.top.color = "black",
    row_group.border.bottom.color = "white",
    table.border.bottom.color = "white",
    column_labels.border.top.color = "black",
    column_labels.border.bottom.color = "black",
    table_body.border.bottom.color = "black",
    table_body.hlines.color = "white"
  )  %>% 
   tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_body(rows = c(4, 13, 24, 37))
  ) %>% 
  tab_row_group(
    group = "Diabetic retinopathy screening coverage 2011-2019",
    rows = 31:40
  ) %>% 
  tab_row_group(
    group = "Diabetic retinopathy screening coverage 2011-2023",
    rows =21:30
  ) %>% 
  tab_row_group(
    group = "Diabetic glycemic control coverage 2011-2019",
    rows = 11:20
  ) %>% 
  tab_row_group(
    group = "Diabetic glycemic control coverage 2011-2023",
    rows =1:10
  ) %>% 
  tab_source_note(source_note = md("**Abbreviations:** LCMM - Latent class mixture model; BIC - Bayesian information criterion; SCS - Smallest class size; APPA - Average posterior probability; MMV - Mismatch value; OCC - Odds of correct classification. * Model did not converge; BIC not reliable.")) %>% 
  tab_header(
    title = md("**Supplementary Table S4. Description of the 10 candidate model structures tested in the LCMM analysis**"))

```

```{r}
#| label: individual-trajectories-plot
#| echo: false
#| message: false
#| warning: false
#| fig-width: 10
#| fig-height: 12

# ðŸ“‚ Cargar el archivo de modelos
all_named_models <- readRDS("all_named_models.rds")

# ðŸ“‹ Definir cuÃ¡les modelos quieres graficar
model_names_to_plot <- c(
  "5class_cubic_nre_dgcc_model_2011_2023",
  "4class_quadratic_nre_dgcc_model_2011_2019",
  "4class_cubic_nre_drsc_model_2011_2023",
  "4class_quadratic_random_effects_prop_drsc_model_2011_2019"
)

# ðŸ·ï¸ Etiquetas de las trayectorias
trajectory_labels <- list(
  `5class_cubic_nre_dgcc_model_2011_2023` = c(
    "Consistently lower", "Stable medium", "Stable upper medium", "Deteriorating", "Highest"
  ),
  `4class_quadratic_nre_dgcc_model_2011_2019` = c(
    "Consistently lower", "Stable medium", "Stable upper medium", "Highest"
  ),
  `4class_cubic_nre_drsc_model_2011_2023` = c(
    "Consistently low", "Stable medium", "Increasing", "Highest decreasing"
  ),
  `4class_quadratic_random_effects_prop_drsc_model_2011_2019` = c(
    "Consistently low", "Stable medium", "Recovering", "Highest"
  )
)

# ðŸ·ï¸ TÃ­tulos de los modelos
model_titles <- c(
  "5class_cubic_nre_dgcc_model_2011_2023" = "Five-class model for glycaemic control (2011â€“2023)",
  "4class_quadratic_nre_dgcc_model_2011_2019" = "Four-class model for glycaemic control (2011â€“2019)",
  "4class_cubic_nre_drsc_model_2011_2023" = "Four-class model for DR screening (2011â€“2023)",
  "4class_quadratic_random_effects_prop_drsc_model_2011_2019" = "Four-class model for DR screening (2011â€“2019)"
)

# âš™ï¸ Crear los grÃ¡ficos
individual_trajectories_plots <- purrr::map(model_names_to_plot, function(model_name) {
  
  model <- all_named_models[[model_name]]
  
  # âœ… VerificaciÃ³n de componentes
  if (is.null(model) || is.null(model$call$data) || is.null(model$pred) || is.null(model$pprob)) {
    cat(paste0("âš ï¸ Skipping model: ", model_name, "\n"))
    return(NULL)
  }
  
  # ðŸ” Outcome variable
  outcome_var <- ifelse(str_detect(model_name, "dgcc"), "dgcc", "drsc")
  
  # ðŸ› ï¸ Preprocesar datos
  model_data <- model$call$data %>%
    arrange(id, year) %>%
    group_by(id) %>%
    mutate(row_id = row_number()) %>%
    ungroup()
  
  pred_data <- model$pred
  
  # ðŸ”¥ Verificar si pred_data tiene columna "time"
  if ("time" %in% names(pred_data)) {
    pred_data <- pred_data %>%
      arrange(id, time)
  } else {
    pred_data <- pred_data %>%
      arrange(id)
  }
  
  pred_data <- pred_data %>%
    group_by(id) %>%
    mutate(row_id = row_number()) %>%
    ungroup()
  
  merged_df <- left_join(model_data, pred_data, by = c("id", "row_id")) %>%
    left_join(model$pprob, by = "id") %>%
    filter(!is.na(class))
  
  # ðŸ§¹ Ordenar las clases
  class_order <- merged_df %>%
    group_by(class) %>%
    dplyr::summarise(mean_val = mean(.data[[outcome_var]], na.rm = TRUE), .groups = "drop") %>%
    arrange(mean_val) %>%
    mutate(class_order = row_number())
  
  merged_df <- merged_df %>%
    left_join(class_order, by = "class") %>%
    mutate(class = class_order)
  
  label_df <- merged_df %>%
    distinct(id, class) %>%
    group_by(class) %>%
    dplyr::summarise(n = n(), .groups = "drop") %>%
    mutate(
      percentage = n / sum(n),
      label = paste0(trajectory_labels[[model_name]], " (", percent(percentage, accuracy = 0.1), ")")
    ) %>%
    arrange(class)
  
  merged_df <- merged_df %>%
    left_join(label_df, by = "class") %>%
    mutate(label = factor(label, levels = label_df$label))
  
  # ðŸŽ¨ Construir el grÃ¡fico
  ggplot(merged_df, aes(x = year, y = .data[[outcome_var]], group = id, color = label)) +
    geom_line(alpha = 0.15, linewidth = 0.3) +
    stat_summary(fun = mean, geom = "line", aes(group = label), linewidth = 0.9) +
    facet_wrap(~ label, nrow = 1, strip.position = "top") +
    scale_color_lancet() +
    scale_y_continuous(limits = c(0, 1), labels = percent) +
    scale_x_continuous(breaks = seq(1, 13, by = 2), labels = seq(2011, 2023, by = 2)) +
    labs(
      title = model_titles[[model_name]],
      x = "Year",
      y = ifelse(outcome_var == "dgcc", 
                 "Proportion of T2DM individuals with HbA1c < 7%", 
                 "Proportion of T2DM individuals with annual DR screening")
    ) +
    theme_minimal(base_size = 10) +
    theme(
      strip.text = element_text(size = 8, face = "bold"),
      plot.title = element_text(size = 10, face = "bold", hjust = 0),
      axis.text = element_text(size = 7),
      axis.title = element_text(size = 8.5),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      legend.position = "none"
    )
})

# ðŸ§© Combinar plots vÃ¡lidos
wrap_plots(purrr::compact(individual_trajectories_plots), ncol = 1) +
  plot_annotation(
    title = "Raw individual trajectories by latent class (ordered within model)",
    subtitle = "Each facet uses model-specific class ordering and consistent color palette",
    theme = theme(
      plot.title = element_text(size = 13, face = "bold", hjust = 0),
      plot.subtitle = element_text(size = 10, hjust = 0)
    )
  )
```

```{r}
#| echo: false
#| message: false
#| warning: false
#| fig-height: 9
#| fig-width: 10
#| paged-print: false
#| fig-align: center

# ðŸ“‚ Load data
coverage_data <- read.csv("coverage_2011_2023_noq1.csv") %>%
  arrange(comuna2, ano) %>%
  mutate(
    year = ano - min(ano) + 1,
    id = comuna2,
    drsc = drs_coverage,
    dgcc = dm_coverage
  )

all_named_models <- readRDS("all_named_models.rds")

trajectory_labels <- list(
  `5class_cubic_nre_dgcc_model_2011_2023` = c("Consistently lower", "Stable medium", "Stable upper medium", "Deteriorating", "Highest"),
  `4class_quadratic_nre_dgcc_model_2011_2019` = c("Consistently lower", "Stable medium", "Stable upper medium", "Highest"),
  `4class_cubic_nre_drsc_model_2011_2023` = c("Consistently low", "Stable medium", "Increasing", "Highest decreasing"),
  `4class_quadratic_random_effects_prop_drsc_model_2011_2019` = c("Consistently low", "Stable medium", "Recovering", "Highest")
)

model_names_to_plot <- c(
  "5class_cubic_nre_dgcc_model_2011_2023",
  "4class_quadratic_nre_dgcc_model_2011_2019",
  "4class_cubic_nre_drsc_model_2011_2023",
  "4class_quadratic_random_effects_prop_drsc_model_2011_2019"
)

selected_models <- all_named_models[model_names_to_plot]
residual_plot_list <- list()

# ðŸ“ˆ Loop for models
for (i in seq_along(selected_models)) {
  
  model_name <- names(selected_models)[i]
  model <- selected_models[[i]]
  
  outcome_var <- ifelse(grepl("drsc", model_name, ignore.case = TRUE), "drsc", "dgcc")
  
  model_data <- model$call$data %>%
    group_by(id) %>%
    mutate(row_id = row_number()) %>%
    ungroup()
  
  pred_df <- model$pred %>%
    group_by(id) %>%
    mutate(row_id = row_number()) %>%
    ungroup()
  
  merged_df <- left_join(model_data, pred_df, by = c("id", "row_id")) %>%
    left_join(model$pprob, by = "id") %>%
    filter(!is.na(class)) %>%
    rowwise() %>%
    mutate(
      pred = get(paste0("pred_m", class)),
      prob = get(paste0("prob", class)),
      residual = .data[[outcome_var]] - pred
    ) %>%
    ungroup()
  
  summary_residuals <- merged_df %>%
    group_by(year, class) %>%
    dplyr::summarise(
      mean_obs = wtd.mean(obs, weights = prob, na.rm = TRUE),
      sd_resid = sqrt(wtd.var(residual, weights = prob, na.rm = TRUE)),
      lower = mean_obs - sd_resid,
      upper = mean_obs + sd_resid,
      .groups = "drop"
    ) %>%
    mutate(model = model_name)
  
  # Reorder classes based on average mean
  class_order <- summary_residuals %>%
    group_by(class) %>%
    dplyr::summarise(avg_mean_obs = mean(mean_obs, na.rm = TRUE)) %>%
    arrange(avg_mean_obs) %>%
    mutate(order_class = row_number())
  
  # Assign labels based on order_class
  class_percentages <- merged_df %>%
    distinct(id, class) %>%
    left_join(class_order, by = "class") %>%
    group_by(order_class) %>%
    dplyr::summarise(n = n(), .groups = "drop") %>%
    mutate(percentage = n / sum(n)) %>%
    arrange(order_class)
  
  trajectory_vector <- trajectory_labels[[model_name]]
  
  if (length(trajectory_vector) != nrow(class_percentages)) {
    stop("âš ï¸ NÃºmero de etiquetas no coincide con el nÃºmero de clases")
  }
  
  class_percentages <- class_percentages %>%
    mutate(label = paste0(trajectory_vector, " (", percent(percentage, accuracy = 0.1), ")"))
  
  # Final dataset for plotting
  summary_residuals_plot <- summary_residuals %>%
    left_join(class_order, by = "class") %>%
    left_join(class_percentages %>% select(order_class, label), by = "order_class") %>%
    mutate(label = factor(label, levels = class_percentages$label))
  
  # Y-axis label
  y_axis_label <- if (grepl("dgcc", model_name, ignore.case = TRUE)) {
    "Proportion of T2DM individuals with HbA1C < 7%"
  } else {
    "Proportion of T2DM individuals with annual DR screening"
  }
  
  # ðŸ“ˆ Build plot
  plot_residual <- ggplot(summary_residuals_plot, aes(x = year, group = label)) +
    geom_line(aes(y = mean_obs, color = label), linewidth = 0.8) +
    geom_ribbon(aes(ymin = lower, ymax = upper, fill = label), alpha = 0.2) +
    scale_x_continuous(breaks = seq(1, 13, by = 2), labels = seq(2011, 2023, by = 2)) +
    scale_y_continuous(limits = c(0, 1), labels = percent) +
    scale_color_lancet(
      na.translate = FALSE,
      guide = guide_legend(override.aes = list(linetype = "solid", shape = NA))
    ) +
    scale_fill_lancet(guide = "none") +
    labs(
      x = "Year",
      y = y_axis_label,
      color = "Latent class"
    ) +
    theme_bw() +
    guides(color = guide_legend(nrow = 2, byrow = TRUE, title.position = "top", title.hjust = 0)) +
    theme(
      legend.position = c(0.02, 0.98),
      legend.justification = c(0, 1),
      legend.direction = "horizontal",
      legend.box = "horizontal",
      legend.margin = margin(t = 1, b = 1, r = 1, l = 1),
      legend.key.size = unit(0.2, "cm"),
      legend.background = element_rect(fill = "transparent", color = NA),
      legend.text = element_text(size = 7),
      legend.title = element_text(size = 8, face = "bold"),
      axis.text = element_text(size = 6.5),
      axis.title = element_text(size = 7.5),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank()
    )
  
  residual_plot_list[[i]] <- plot_residual
}

# ðŸ–¼ Titles
dgcc_title <- patchwork::wrap_elements(grid::textGrob(
  "Diabetic glycaemic control coverage residual Elsensohn envelopes plots", 
  x = 0, hjust = 0, gp = grid::gpar(fontface = "bold", fontsize = 13)
))

drsc_title <- patchwork::wrap_elements(grid::textGrob(
  "Diabetic retinopathy screening coverage residual Elsensohn envelopes plots", 
  x = 0, hjust = 0, gp = grid::gpar(fontface = "bold", fontsize = 13)
))

# ðŸ§© Final combination
combined_plot <- (
  dgcc_title / (residual_plot_list[[1]] | residual_plot_list[[2]]) /
    drsc_title / (residual_plot_list[[3]] | residual_plot_list[[4]])
) +
  patchwork::plot_layout(heights = c(0.1, 1, 0.1, 1))

combined_plot



```

```{r}
#| echo: false
#| message: false
#| warning: false
#| paged-print: false


library(dplyr)
library(gt)

grolts_completed <- tibble::tibble(
  Items = c(
    "1. Is the Metric of Time Used in the Statistical Model Reported?",
    "2. Is Information Presented About the Mean and Variance of Time Within a Wave?",
    "3a. Is the missing data mechanism reported? Yes/No",
    "3b. Is a description provided of what variables are related to attrition/missing data?",
    "3c. Is a description provided of how missing data in the analyses were dealt with",
    "4. Is information about the distribution of the observed variables included?",
    "5. Is the software mentioned",
    "6a. Are Alternative Specifications of Within-Class Heterogeneity Considered? (EG LGCA vs LGMM) and clearly documented?",
    "6b. Are alternative specifications of Between-Class Differences in variance-covariance matrix structure considered and documented.",
    "7. Are Alternative Shape and Functional Forms of the Trajectories Described?",
    "8. If covariates are used, can analysis still be replicated",
    "9. Is information reported about the number of random start values and final iterations included?",
    "10. Are the model comparison tools used described?",
    "11. Are the Total Number of Fitted Models Reported? Including the One-Class Solution?",
    "12. Are the number of cases per class reported?",
    "13. If classification of cases in a trajectory is the goal, is entropy reported?",
    "14a. Is a plot included with the estimated trajectories for the Final Solution",
    "14b. Are Plots included with the estimated mean trajectories for each model?",
    "14c. Is a Plot Included of the Combination of Estimated Means of the Final Model and Observed Individual Trajectories Split out for Each Latent Class",
    "15. Are the characteristics of the Final Class Solution Numerically Described?",
    "16. Are the syntax files Available?"
  ),
  Reported = c(
    "Yes", "Yes", "Yes", "Partial", "Yes",
    "Yes", "Yes", "Yes", "Yes", "Yes",
    "Yes", "No", "Yes", "Yes", "Yes",
    "Yes", "Yes", "Yes", "Yes", "Yes",
    "Yes"
  ),
  Reason = c(
    "Annual observations from 2011 to 2023 used as the time metric.",
     "Annual mean coverage is reported in Figure 1, and within-wave variability is presented through 95% confidence intervals in Figures 1 and 2, stratified by outcome and latent class.",
    "Yes â€“ The missing data mechanism is reported for both outcomes and covariates. Inclusion rules are defined by the health system (e.g., exclusion after failed contact for HbA1c); all covariates (deprivation, urbanicity, and geographical zone) were complete; and municipalities in the lowest diabetes population quintile were excluded to reduce bias from unstable denominators.",
    "Partial. Only DGCC discusses exclusions after failed contact attempts; DRSC includes all diagnosed cases.",
    "Yes. Non-tested individuals excluded from DGCC denominator; full inclusion for DRSC.",
    "Yes. Summary plots and spaghetti plots show dispersion across time and classes.",
    "Yes. R version 4.4.2 with lcmm package (v2.1.0) was used.",
    "Yes. Homoscedastic, heteroscedastic, and random effect models compared.",
    "Yes. Structures Aâ€“J tested with and without random effects.",
    "Yes. Linear, quadratic, and cubic trajectories explicitly compared.",
    "Yes. All covariates and modeling steps are described; replicability is feasible.",
    "Yes. Methods. 200 random sets and a maximum of 1500 iterations for two or more class models",
    "Yes. Supplementary Table S2. BIC, OCC, APPA, mismatch, entropy. Elbow BIC plots all used. Supplementary Fifure S2-S5",
    "Yes. The total number of fitted models is reported and includes the one-class solution. Specifically, we tested 10 model structures (Supplementary Table S1), each evaluated across 1 to 7 latent classes, resulting in 70 fitted models per outcome-period combination. The one-class solution (K = 1) served as a reference point for assessing model structure adequacy and was included in residual diagnostics and BIC evaluations.",
    "Yes. Minimum class size threshold (2%) reported and ensured.",
    "Yes. Reported entropy values ranged between 0.67 and 0.85.",
    "Yes. Figures show final class-specific trajectories.",
    "Yes. Multiple plots with mean trajectories presented.",
    "Yes. Spaghetti plots for each class provided.",
    "Yes. OCC, APPA, entropy, mismatch, and class size included.",
    "Yes. All syntax files and documentation are available in a public GitHub repository."
  )
)

grolts_completed %>%
  gt() %>%
  tab_options(
    table.font.size = 10,
    data_row.padding = px(0),
    table.border.top.color = "black",
    heading.border.bottom.color = "black",
    row_group.border.top.color = "black",
    row_group.border.bottom.color = "white",
    table.border.bottom.color = "white",
    column_labels.border.top.color = "black",
    column_labels.border.bottom.color = "black",
    table_body.border.bottom.color = "black",
    table_body.hlines.color = "white"
  )  %>% 
  tab_header(
    title = md("**Supplementary Table S5. Reporting of latent growth modeling approach using the GRoLTS checklist**")
  )





grolts_completed2 <- tibble::tibble(
  Question = c(
    "1. Is the Metric of Time Used in the Statistical Model Reported?",
    "2. Is Information Presented About the Mean and Variance of Time Within a Wave?",
    "3a. Is the missing data mechanism reported?",
    "3b. Is a description provided of what variables are related to attrition/missing data?",
    "3c. Is a description provided of how missing data in the analyses were dealt with",
    "4. Is information about the distribution of the observed variables included?",
    "5. Is the software mentioned",
    "6a. Are Alternative Specifications of Within-Class Heterogeneity Considered?",
    "6b. Are alternative specifications of Between-Class Differences in variance-covariance matrix structure considered and documented.",
    "7. Are Alternative Shape and Functional Forms of the Trajectories Described?",
    "8. If covariates are used, can analysis still be replicated",
    "9. Is information reported about the number of random start values and final iterations included?",
    "10. Are the model comparison tools used described?",
    "11. Are the Total Number of Fitted Models Reported? Including the One-Class Solution?",
    "12. Are the number of cases per class reported?",
    "13. If classification of cases in a trajectory is the goal, is entropy reported?",
    "14a. Is a plot included with the estimated trajectories for the Final Solution",
    "14b. Are Plots included with the estimated mean trajectories for each model?",
    "14c. Is a Plot Included of the Combination of Estimated Means of the Final Model and Observed Individual Trajectories Split out for Each Latent Class",
    "15. Are the characteristics of the Final Class Solution Numerically Described?",
    "16. Are the syntax files Available?"
  ),
  `Yes/No` = c(
    "Yes", "Yes", "Yes", "Yes", "Yes",
    "Partially", "Yes", "Yes", "Yes", "Yes",
    "Yes", "Yes", "Yes", "Yes", "Yes",
    "Yes", "Yes", "Yes", "Yes", "Yes",
    "Yes"
  ),
  `Section Reported` = c(
    "Methods â€“ Study design and statistical analysis",
    "Methods â€“ Study design",
    "Methods â€“ Missing data handling",
    "Methods â€“ Missing data handling",
    "Methods â€“ Missing data handling",
    "Methods â€“ Covariates description",
    "Methods â€“ Statistical analysis",
    "Methods â€“ Statistical analysis",
    "Methods â€“ Statistical analysis",
    "Methods â€“ Statistical analysis",
    "Methods â€“ Covariate definitions and GitHub link",
    "Methods â€“ Statistical analysis",
    "Methods â€“ Statistical analysis",
    "Methods â€“ Statistical analysis",
    "Results â€“ Model adequacy",
    "Results â€“ Model adequacy",
    "Results â€“ Graphical presentation",
    "Results â€“ Graphical presentation",
    "Results â€“ Graphical presentation",
    "Results â€“ Model adequacy",
    "Methods â€“ Software and GitHub statement"
  ),
  Justification = c(
    "Annual time points from 2011 to 2023 are clearly described as the temporal metric used in the latent class mixed models.",
    "Time is consistent across municipalities as it is yearly data; no variation within waves, but the design clarifies this structure.",
    "Data exclusions are based on administrative rules and design; missing data mechanisms are explicitly described.",
    "Explains exclusion rules and that no variables are directly related to missingness; missingness is structural.",
    "Complete case analysis is performed, with no imputation needed due to curated dataset and exclusions.",
    "Municipal-level covariates are described, but summary statistics should be added in a table (recommended Table 1).",
    "R version 4.4.2 and lcmm package version 2.1.0 are reported.",
    "Ten model structures tested with and without random effects and heteroscedasticity.",
    "Model structure and residual envelope diagnostics were used to test class-specific variance assumptions.",
    "Linear, quadratic, and cubic specifications tested and compared using residual patterns and BIC.",
    "All covariates are defined and public; syntax files available via GitHub ensure replicability.",
    "200 random starts and 1500 max iterations are specified.",
    "BIC, entropy, APPA, OCC, and mismatch metrics are used and documented.",
    "Models with 1 to 7 classes across 10 structures were tested, including the one-class model.",
    "Minimum class size >2% is stated; class sizes illustrated in figures.",
    "Relative entropy is reported for each final model (0.67â€“0.85).",
    "Figures 1 and 2 display estimated trajectories for final models.",
    "Plots with 95% predictive intervals are included.",
    "Spaghetti plots included as Supplementary Figure S7.",
    "All adequacy metrics (APPA, OCC, entropy, mismatch) are presented.",
    "All syntax files and documentation are available on GitHub (link provided)."
  )
)

# View the table
grolts_completed2 %>%
  gt() %>%
  tab_options(
    table.font.size = 10,
    data_row.padding = px(0),
    table.border.top.color = "black",
    heading.border.bottom.color = "black",
    row_group.border.top.color = "black",
    row_group.border.bottom.color = "white",
    table.border.bottom.color = "white",
    column_labels.border.top.color = "black",
    column_labels.border.bottom.color = "black",
    table_body.border.bottom.color = "black",
    table_body.hlines.color = "white"
  )  %>% 
  tab_header(
    title = md("**Supplementary Table S5. Reporting of latent growth modeling approach using the GRoLTS checklist**")
  )




```

```{r}
#| label: tbl-S4
#| tbl-cap: "Logistic regression 2011-2019"
#| fig-align: center
#| results: "asis"


d1 <- readr::read_csv("data_reglog.csv")
d2 <- readr::read_csv("data_reglog2.csv")

# Model 5: Single predictor (index_standardized)
model5 <- glm(class_membership ~ index_standardized, family = "binomial", data = d2)
# Model 5a: Single predictor (classification)
model5a <- glm(class_membership ~ classification, family = "binomial", data = d2)
# Model 5b: Single predictor (zona)
model5b <- glm(class_membership ~ zona, family = "binomial", data = d2)
# Model 5c: All predictors
model5c <- glm(class_membership ~ index_standardized + classification + zona, family = "binomial", data = d2)
# Model 6: Two predictors (index_standardized + classification)
model6 <- glm(class_membership ~ index_standardized + classification, family = "binomial", data = d2)
# Model 6a: Two predictors (index_standardized + zona)
model6a <- glm(class_membership ~ index_standardized + zona, family = "binomial", data = d2)
# Model 6b: Two predictors (classification + zona)
model6b <- glm(class_membership ~ classification + zona, family = "binomial", data = d2)



models2 <- list("M1" = model5, 
               "M2" = model5a, 
               "M3" = model5b,
               "M4" = model6, 
               "M5" = model6a,
               "M6" = model6b,
               "M7" = model5c)
  
# additionally we want to change the font, font size and spacing
modelsummary(models2,
output = 'gt',
coef_map = c("index_standardized" = "Deprivation (Standarized ISDE score)",
             "classificationRural" = "Urbanicity (Rural)",
             "classificationUrbana" = "Urbanicity (Urban)",
            "zonanorte" = "Zone (North)",
            "zonasur" = "Zone (South)"),
#stars = T,
#estimate = "{estimate}{stars}",
statistic = c("SE = {std.error}", 
                "p = {p.value}{stars}"),
notes = "Notes: + p < 0.1, * p < 0.05, ** p < 0.01, *** p < 0.001") %>%
tab_spanner(label = 'Dependent variable: DRSC class', columns = 2:8) %>%
tab_options(
table.font.size = 10,
data_row.padding = px(1),
table.border.top.color = "white",
heading.border.bottom.color = "black",
row_group.border.top.color = "black",
row_group.border.bottom.color = "white",
table.border.bottom.color = "white",
column_labels.border.top.color = "black",
column_labels.border.bottom.color = "black",
table_body.border.bottom.color = "black",
table_body.hlines.color = "white"
) %>% 
  tab_row_group(
    group = "",
    rows = 1:15
  )




```

```{r}
#| label: tbl-S5
#| tbl-cap: "Logistic regression 2011-2023"
#| fig-align: left
#| results: "asis"


# Model 1: Single predictor (index_standardized)
model1 <- glm(class_membership ~ index_standardized, family = "binomial", data = d1)
# Model 1a: Single predictor (classification)
model1a <- glm(class_membership ~ classification, family = "binomial", data = d1)
# Model 1b: Single predictor (zona)
model1b <- glm(class_membership ~ zona, family = "binomial", data = d1)
# Model 1c: All predictors
model1c <- glm(class_membership ~ index_standardized + classification + zona, family = "binomial", data = d1)
# Model 2: Two predictors (index_standardized + classification)
model2 <- glm(class_membership ~ index_standardized + classification, family = "binomial", data = d1)
# Model 2a: Two predictors (index_standardized + zona)
model2a <- glm(class_membership ~ index_standardized + zona, family = "binomial", data = d1)
# Model 2b: Two predictors (classification + zona)
model2b <- glm(class_membership ~ classification + zona, family = "binomial", data = d1)

models <- list("M1" = model1, 
               "M2" = model1a, 
               "M3" = model1b,
               "M4" = model2, 
               "M5" = model2a,
               "M6" = model2b,
               "M7" = model1c)
  
# additionally we want to change the font, font size and spacing
modelsummary(models,
output = 'gt',
coef_map = c("index_standardized" = "Deprivation (Standarized ISDE score)",
             "classificationRural" = "Urbanicity (Rural)",
             "classificationUrbana" = "Urbanicity (Urban)",
            "zonanorte" = "Zona (Norte)",
            "zonasur" = "Zona (Sur)"),
#stars = T,
#estimate = "{estimate}{stars}",
statistic = c("SE = {std.error}", 
                "p = {p.value}{stars}"),
notes = "Notes: + p < 0.1, * p < 0.05, ** p < 0.01, *** p < 0.001") %>%
tab_spanner(label = 'Dependent variable: DRSC class', columns = 2:8) %>%
tab_options(
table.font.size = 10,
data_row.padding = px(1),
table.border.top.color = "white",
heading.border.bottom.color = "black",
row_group.border.top.color = "black",
row_group.border.bottom.color = "white",
table.border.bottom.color = "white",
column_labels.border.top.color = "black",
column_labels.border.bottom.color = "black",
table_body.border.bottom.color = "black",
table_body.hlines.color = "white"
) %>% 
  tab_row_group(
    group = "",
    rows = 1:15
  )


```

```{r}
#| label: tbl-S6
#| tbl-cap: "Framework of eight steps to construct a latent class trajectory model"
#| fig-align: left

tibble::tibble(
  Step = 1:8,
  `Step description` = c(
    "Scope model by provisionally selecting a plausible number of classes based on available literature and the structure based on plausible clinical patterns.",
    "Refine the model from step 1 to confirm the optimal number of classes, typically testing K=1â€“7 classes.",
    "Refine optimal model structure from fixed through to unrestricted random effects of the model using the favoured K derived in step 2.",
    "Run model adequacy assessments as described in online supplementary table S3 including posterior probability of assignments (APPA), odds of correct classification (OCC) and relative entropy.",
    "Investigate graphical presentation",
    "Run additional tools to assess discrimination including Degrees of separation (DoS) and Elsensohnâ€™s envelope of residuals",
    "Assess for clinical characterisation and plausibility.",
    "Conduct sensitivity analyses, for example, testing models without complete data at all time points."
  ),
  `Criteria for selection` = c(
    "Examine linearity of the shape of standardised residual plots for each of the classes in a model with no random effects.",
    "Lowest Bayesian information criteria value.",
    "",
    "APPA: average of maximum probabilities should be greater than 70% for all classes.\nOCC values greater than 5.0.\nRelative entropy values greater than 0.5.",
    "Plot mean trajectories across time for each class in a single graph.\nPlot mean trajectories with 95% predictive intervals for each class (one class per graph).\nPlot individual class â€˜spaghetti plotsâ€™ across time for a random sample.",
    "DoS greater than zero.\nEnvelope of residuals is assessed in plots by observing clear separations between classes.",
    "Tabulation of characteristics by latent classes. Are the trajectory patterns clinically meaningful? Perhaps, consider classes with a minimum percentage of the population.\nAre the trajectory patterns clinically plausible?\nConcordance of class characteristics with those for other well-established variables.",
    "General assessment of patterns of trajectories compared with main model."
  )
) %>%
  gt::gt() %>%
  #tab_spanner(label = 'Model fit and diagnostic criteria', columns = 2:16) %>%
  tab_options(
    table.font.size = 10,
    data_row.padding = px(1),
    table.border.top.color = "black",
    heading.border.bottom.color = "black",
    row_group.border.top.color = "black",
    row_group.border.bottom.color = "white",
    table.border.bottom.color = "white",
    column_labels.border.top.color = "black",
    column_labels.border.bottom.color = "black",
    table_body.border.bottom.color = "black",
    table_body.hlines.color = "white") 
```
